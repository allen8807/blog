# Java 虚拟机规范(Java SE7版)
#### The Java Virtual Machine Specification SE7

### 第 1 章 引言
* Java 语言是一门通用的、面向对象的、支持并发的程序语言。
* Java 虚拟机是整个 Java 平台的基石,是 Java 技术用以实现硬件无关与操作系统无关的关键部分,是 Java 语言生成出极小体积的编译代码的运行平台,是保障用户机器免于恶意代码损害 的保护屏障。
* Java 虚拟机与 Java 语言并没有必然的联系,它只与特定的二进制文件格式——Class 文件 格式所关联,Class 文件中包含了 Java 虚拟机指令集(或者称为字节码、Bytecodes)和符号 表,还有一些其他辅助信息。
* 基于安全方面的考虑,Java 虚拟机要求在 Class 文件中使用了许多强制性的语法和结构化 约束,但任一门功能性语言都可以表示为一个能被 Java 虚拟机接收的有效的 Class 文件。作为 一个通用的、机器无关的执行平台,任何其他语言的实现者都可以将 Java 虚拟机作为他们语言的 产品交付媒介。

### 第 2 章 Java 虚拟机结构

* 编译后被 Java 虚拟机所执行的代码使用了一种平台中立(不依赖于特定硬件及操作系统的) 的二进制格式来表示,并且经常(但并非绝对)以文件的形式存储,因此这种格式被称为 Class 文件格式。Class 文件格式中精确地定义了类与接口的表示形式,包括在平台相关的目标文件格 式中一些细节上的惯例1,例如字节序(Byte Ordering)等。
* Java 虚拟机可以操作的数据类型可分为两类:原始类 型(Primitive Types,也经常翻译为原生类型或者基本类型)和引用类型(Reference Types)。
* Java 虚拟机是直接支持对象的
* 虚拟机中使用 reference 类型来表示对某个对象的引用,reference 类型的 值读者可以想象成类似于一个指向对象的指针。每一个对象都可能存在多个指向它的引用,对象的 操作、传递和检查都通过引用它的 reference 类型的数据进行操作。
* Java 虚拟机所支持的原始数据类型包括了数值类型(Numeric Types)、布尔类型(Boolean Type §2.3.4)和 returnAddress 类型(§2.3.3)三类。其中数值类型又分为整型类型 (Integral Types,§2.3.1)和浮点类型(Floating-Point Types,§2.3.2)两种
* int 类型:值为 32 位有符号二进制补码整数,默认值为零。
* double 类型:取值范围是双精度浮点数集合中的元素,或者(如果虚拟机支持的话)是 双精度扩展指数(Double-Extended-Exponent)集合中的元素。默认值为正数零。
* boolean 类型:取值范围为布尔值 true 和 false,默认值为 false。
* returnAddress 类型:表示一条字节码指令的操作码(Opcode)。在所有的虚拟机支持的原始类型之中,只有 returnAddress 类型是不能直接 Java 语言的数据类型对应 起来的。
* 对于一个非零的、可数的任意浮点值,都可以表示为 s×m×2<sup>(e-N+1)</sup>的形式,其中 s 可以是 +1 或者-1,m 是一个小于 2N 的正整数,e 是一个介于 Emin=-(2<sup>K-1</sup>-2)和 Emax=2<sup>K-1</sup>-1 之间的整 数(包括 Emin 和 Emax)。这里的 N 和 K 两个参数的取值范围决定于当前采用的浮点数值集合。
* 所有 Java 虚拟机的实现都必须支持两种标准的浮点数值集合:单精度浮点数集合和双精度浮 点数集合。另外,Java 虚拟机实现可以自由选择是否要支持单精度扩展指数集合和双精度扩展指 数集合,也可以选择支持其中的一种或全部。这些扩展指数集合可能在某些特定情况下代替标准浮 点数集合来表示 float 和 double 类型的数值。
* 上述四种数值集合都不仅包含可数的非零值,还包括五个特殊的数值:正数零、负数零、正无 穷大、负无穷大和 NaN。
* returnAddress 类型会被 Java 虚拟机的 jsr、ret 和 jsr_w 指令所使用。
* 这几条指令以前主要被使用来实现 finally 语句块,后来改为冗余 finally 块代码的方式来实 现,甚至到了 JDK7 时,虚拟机已不允许 Class 文件内出现这几条指令。那相应地,returnAddress 类型就处 于名存实亡的状态。
*  Java 虚拟机定义了 boolean 这种数据类型,但是只对它提供了非常有限的支持。在 Java 虚拟机中没有任何供 boolean 值专用的字节码指令,在 Java 语言之中涉及到 boolean 类型值的运算,在编译之后都使用 Java 虚拟机中的 int 数据类型来代替。
*  Java 虚拟机直接支持 boolean 类型的数组,虚拟机的 newarray 指令可以创建这种数组。boolean 的数组类型的访问与修改共用 byte 类型数组的 baload 和 bastore 指令。
*  在 Oracle 公司的虚拟机实现里,Java 语言里面的 boolean 数组将会被编码成 Java 虚拟机的 byte 数 组,每个 boolean 元素占 8 位长度。
*  Java虚拟机中有三种引用类型:类类型(Class Types)、数组类型(Array Types)和 接口类型(Interface Types)。
* 2.5 运行时数据区
* Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区,其中有一些会随着虚拟机 启动而创建,随着虚拟机退出而销毁。
  *  2.5.1 PC 寄存器
    *  Java 虚拟机可以支持多条线程同时执行,每一条 Java 虚拟机线程都有自己的PC(Program Counter)寄存器。
  *  2.5.2 Java 虚拟机栈
    *  这个栈与线程同时创建,用于存储栈帧
    *  栈帧可以在堆中分配,Java 虚拟机栈所使用的内存不需要保证是连 续的。
    *  如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量时,Java 虚拟机将会抛出一个 StackOverflowError 异常。
    *   如果 Java 虚拟机栈可以动态扩展,并且扩展的动作已经尝试过,但是目前无法申请到足够的内存去完成扩展,或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈,那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。
  * 2.5.3 Java 堆
    * 在 Java 虚拟机中,堆(Heap)是可供各条线程共享的运行时内存区域,也是供所有类实例 和数组对象分配内存的区域。
    * Java 堆在虚拟机启动的时候就被创建,它存储了被自动内存管理系统(Automatic Storage Management System,也即是常说的“Garbage Collector(垃圾收集器)”)所管理的各种 对象,这些受管理的对象无需,也无法显式地被销毁。
    * 本规范中所描述的 Java 虚拟机并未假设采 用什么具体的技术去实现自动内存管理系统。虚拟机实现者可以根据系统的实际需要来选择自动内 存管理技术。
    * Java 堆所使用的内存不需要保证是连续的。
    * 如果实际所需的堆超过了自动内存管理系统能提供的最大容量,那Java虚拟机将会抛出一个OutOfMemoryError 异常。
  * 2.5.4 方法区
    * 方法区(Method Area)是可供各条线程共享的运行时内存区域
    * 方法区与传统语言中的编译代码储存区(Storage Area Of Compiled Code)或者操作系统进程 的正文段(Text Segment)的作用非常类似
    * 它存储了每一个类的结构信息,例如运行时常量 池(Runtime Constant Pool)、字段和方法数据、构造函数和普通方法的字节码内容、还包 括一些在类、实例、接口初始化时用到的特殊方法
    * 方法区在虚拟机启动的时候被创建,虽然方法区是堆的逻辑组成部分,但是简单的虚拟机实现 可以选择在这个区域不实现垃圾收集。
    * 方法区在实际内存空间中可以是不连续的。
    * 如果方法区的内存空间不能满足内存分配请求,那Java虚拟机将抛出一个OutOfMemoryError 异常。
  * 2.5.5 运行时常量池
    * 运行时常量池扮演了类似传统语言中符号表(Symbol Table)的角色,不过它存储数据范围比通常意义上的符号表要更为广泛
  * 2.5.6 本地方法栈
    * Java虚拟机实现可能会使用到传统的栈(通常称之为“C Stacks”)来支持native方法 (指使用 Java 以外的其他语言编写的方法)的执行,这个栈就是本地方法栈(Native Method Stack)。
    * 当 Java 虚拟机使用其他语言(例如 C 语言)来实现指令集解释器时,也会使用到本地 方法栈。
    * 如果 Java 虚拟机不支持 natvie 方法,并且自己也不依赖传统栈的话,可以无需支持本 地方法栈,如果支持本地方法栈,那这个栈一般会在线程创建的时候按线程分配。

* 2.6 栈帧
  * 栈帧(Frame)是用来存储数据和部分过程结果的数据结构,同时也被用来处理动态链接 (Dynamic Linking)、方法返回值和异常分派(Dispatch Exception)。
  * 栈帧随着方法调用而创建,随着方法结束而销毁——无论方法是正常完成还是异常完成(抛出 了在方法内未被捕获的异常)都算作方法结束。栈帧的存储空间分配在 Java 虚拟机栈(§2.5.5) 之中,每一个栈帧都有自己的局部变量表(Local Variables,§2.6.1)、操作数栈(Operand Stack,§2.6.2)和指向当前方法所属的类的运行时常量池(§2.5.5)的引用。
  * 在一条线程之中,只有目前正在执行的那个方法的栈帧是活动的。这个栈帧就被称为是当前栈 帧(Current Frame)
  * 当方法返回的之际,当前栈帧会传回此方法的执行结果给前一个栈帧,在方法返回之后,当前栈帧就随之被丢弃,前一个栈帧就重新成为当前栈帧了。 
  * 栈帧是线程本地私有的数据,不可能在一个栈帧之中引用另外一条线程的栈帧。
  * 2.6.1 局部变量表
    * 局部变量使用索引来进行定位访问,第一个局部变量的索引值为零,局部变量的索引值是从零 至小于局部变量表最大容量的所有整数。
    * Java 虚拟机也不要求 double 和 long 类型数据采用 64 位对齐的方式存放在连续的局部变量中
  * 2.6.2 操作数栈
    * 每一个栈帧(§2.6)内部都包含一个称为操作数栈(Operand Stack)的后进先出 (Last-In-First-Out,LIFO)栈。
    * 在操作数栈中的数据必须被正确地操作,这里正确操作是指对操作数栈的操作必须与操作数栈 栈顶的数据类型相匹配
    * 有一小部分Java虚拟机指令(例如 dup 和 swap 指令)可以不关注操作数的具体数据类型,把所有在运行时数据区中的数据当作裸类型(Raw Type)数据来操作,这些指令不可以用来修改数据,也不可以拆散那些原本不可拆分的数据,这些操作的正确性将会通过 Class 文件的校验过程(§4.10)来强制保障。
    * 在任意时刻,操作数栈都会有一个确定的栈深度,一个 long 或者 double 类型的数据会占用 两个单位的栈深度,其他数据类型则会占用一个单位深度。
  * 2.6.3 动态链接
    * 每一个栈帧(§2.6)内部都包含一个指向运行时常量池(§2.5.5)的引用来支持当前方法 的代码实现动态链接(Dynamic Linking)。
    * 动态链接的作用就是 将这些符号引用所表示的方法转换为实际方法的直接引用
    * 由于动态链接的存在,通过晚期绑定(Late Binding)使用的其他类的方法和变量在发生 变化时,将不会对调用它们的方法构成影响。
  * 2.6.4 方法正常调用完成
    * 当前栈帧(§2.6)承担着回复调用者状态的责任
    * 调用者的代 码能在被调用的方法返回并且返回值被推入调用者栈帧的操作数栈后继续正常地执行。
  * 2.6.5 方法异常调用完成
    * 如果方法异常调用完成,那一 定不会有方法返回值返回给它的调用者。
* 2.7 对象的表示
  * Java 虚拟机规范不强制规定对象的内部结构应当如何表示。
* 2.8 浮点算法
  * 2.8.1 Java 虚拟机和 IEEE 754 中的浮点算法
    * 在 Java 虚拟机中的浮点操作在遇到非法操作,如被零除(Divison By Zero)、上限溢出(Overflow)、下限溢出(Underflow)和非精确(Inexact)时,不会抛出exception、trap 或者其他 IEEE 754 异常情况中定义的信号。
    * 在Java虚拟机中不支持IEEE754中的信号浮点比较(SignalingFloating-PointComparisons)。
    * 在 Java 虚拟机中,舍入操作永远使用 IEEE 754 规范中定义的向最接近数舍入模式(Round To Nearest Mode),无法精确表示的结果将会舍入为最接近的可表示值来 保证此值的最低有效位为零(A Zero Least-Significant Bit),这种模式也是 IEEE 754 中的默认模式。
    * 不过在 Java 虚拟机里面,将浮点数转化为整型数是使用向零舍入(Round Toward Zero),这点属于特别定义,并不意味着 Java 虚拟机要改变浮点运算的舍入模式。
    * 在Java虚拟机中不支持IEEE754的单精度扩展和双精度扩展格式(SingleExtended Or Double Extended Format),但是在双精度浮点数集合和双精度扩展指数集合 (Double And Double Extended-Exponent Value Sets,§2.3.2)范围与单 精度扩展指数格式的表示方位会有重叠。
  * 2.8.2 浮点模式
    * 每一个方法都有一项属性称为浮点模式(Floating-Point Mode),取值有两种,要么是 FP-strict 模式要么是非 FP-strict 模式。
  * 2.8.3 数值集合转换
    * 在一些特定场景下,支持扩展指数集合的 Java 虚拟机实现数值在标准浮点数集合与扩展指数 集合之间的映射关系是允许和必要的,这种映射操作就称为数值集合转换。数值集合转换并非数据 类型转换,而是在同一种数据类型之中不同数值集合的映射操作。
    * 在数值集合转换发生的位置,虚拟机实现**允许**对数值执行下面操作之一:
      * 如果一个数值是float类型,并且不是单精度浮点数集合中的元素,允许将其映射到单精度浮点数集合中数值最接近的元素。
      * 如果一个数值是double类型,并且不是双精度浮点数集合中的元素,允许将其映射到双精度浮点数集合中数值最接近的元素。
    * 此外,在数值集合转换发生的位置,下面操作是**必须**的:
      * 假设正在执行的Java虚拟机字节码指令是非FP-strict模式的,但这条指令导致了一个 float 类型的值推入到一个 FP-strict 模式的操作数栈中。如果这个数值不是单精度浮点数集合中的元素,需要将其映射到单精度浮点数集合中数值最接近的元素。
      * 假设正在执行的Java虚拟机字节码指令是非FP-strict模式的,但这条指令导致了一个 double 类型的值推入到一个 FP-strict 模式的操作数栈中。如果这个数值不是双精度浮点数集合中的元素,需要将其映射到双精度浮点数集合中数值最接近的元素。
    * 在方法调用中的参数传递(包括 native 方法的调用)、一个非 FP-strict 模式的方法返回浮点型的结果到 FP-strict 模式的调用者栈帧中或者在非 FP-strict 模式的方法中存储浮点型 数值到局部变量、字段或者数组元素之中都可能会导致上述的数值集合转换发生。
    * 并非所有扩展指数集合中的数值都可以精确映射到标准浮点数值集合的元素之中。
    * 如果进行映 射的数值过大(扩展指数集合的指数可能比标准数值集合的允许最大值要大),无法在标准数值集 合之中精确表示的话,这个数字将会被转化称对应类型的(正或负)无穷大。如果进行映射的数值过大(扩展指数集合的指数可能比标准数值集合的允许最小值要小),无法在标准数值集合之中精确表示的话,这个数字将会被转化成最接近的可以表示非正规值(Denormalized Value,§2.3.2)或者相同正负符号零。
  * 2.9 初始化方法的特殊命名
    * 在 Java 虚拟机层面上,Java 语言中的构造函数在《Java 语言规范 (第三版)》(下文简称 JLS3,§8.8)是以一个名为<init>的特殊**实例初始化方法**的形式出现的,<init>这个方法名称是由编译器命名的,因为它并非一个合法的 Java 方法名字,不可能通过程序编码的方式实现。 
    * **实例初始化方法**只能在实例的初始化期间,通过 Java 虚拟机的 invokespecial 指令来调用, 只有在实例正在构造的时候,实例初始化方法才可以被调用访问(JLS3,§6.6)。
    * 一个类或者接口最多可以包含不超过一个**类或接口的初始化方法**,类或者接口就是通过这个方法完成初始化的(§5.5)。这个方法是一个不包含参数的静态方法,名为<clinit>。这个名字也是由编译器命名的,因为它并非一个合法的 Java 方法名字,不可能通过程序编码的方式实现。
    *  **类或接口的初始化方法**由 Java 虚拟机自身隐式调用,没有任何虚拟机字节码指令可以调用这个方法,只有在类的初始化阶段中会被虚拟机自身调用。
  * 2.10 异常
    * Java 虚拟机里面的异常使用 Throwable 或其子类的实例来表示,抛异常的本质实际上是程序控制权的一种即时的、非局部(Nonlocal)的转换——从异常抛出的地方转换至处理异常的地方。
    * 绝大多数的异常的产生都是由于当前线程执行的某个操作所导致的,这种可以称为是**同步异常**。
    * 与之相对的,**异步异常**是指在程序的其他任意地方进行的动作而导致的异常。
    * Java 虚拟机中异常的出现总是由下面三种原因之一导致的:
      1. 虚拟机同步检测到程序发生了非正常的执行情况,这时异常将会紧接着在发生非正常执行情况的字节码指令之后抛出。例如:
          * 字节码指令所蕴含的操作违反了Java语言的语义,如访问一个超出数组边界范围的元素。
          * 类在加载或者链接时出现错误。
          * 使用某些资源的时候产生资源限制,例如使用了太多的内存。
      * athrow字节码指令被执行。
      * 由于以下原因,导致了异步异常的出现:
          * 调用了Thread或者ThreadGroup的stop方法。
          * Java虚拟机实现的内部程序错误。
          * 当某条线程调用了 stop 方法时,将会影响到其他的线程,或者在线程组中的所有线程。 这时候其他线程中出现的异常就是异步异常,因为这些异常可能出现在程序执行过程的任 何位置。
          * 虚拟机的内部异常也被认为是一种异步异常(§6.3)
    * 抛出异常的动作在 Java 虚拟机之中是一种被精确定义的程序控制权转移过程,当异常抛出、 程序控制权发生转移的那一刻,所有在异常抛出的位置之前的字节码指令所产生的影响都应当是 可以被观察到的,而在异常抛出的位置之后的字节码指令,则应当是没有被执行过的。
    * 如果虚拟机 执行的代码是被优化后的代码,有一些在异常出现位置之后的代码可能已经被执行了,那这些优 化过的代码必须保证被它们提前执行所产生的影响对用户程序来说都是不可见的。
    * 由 Java 虚拟机执行的每一个方法都会配有零至多个异常处理器(Exception Handlers), 异常处理器描述了其在方法代码中的有效作用范围(通过字节码偏移量范围来描述)、能处理的异常类型以及处理异常的代码所在的位置。要判断某个异常处理器是否可以处理某个具体的异常,需要同时检查异常出现的位置是否在异常处理的有效作用范围内并且出现的异常是否异常处理器声明可以处理的异常类型或其子类型两个条件。
    * 当有异常被抛出时,Java 虚拟机搜索当前方法的包含的各个异常处理器,如果能找到可以处理该异常的异常处理器,则将代码控制权转向到异常处理器中描述的处理异常的分支之中。
    * 搜索异常处理器时的搜索顺序是很关键的,在 Class 文件里面,每个方法的异常处理器都存储在一个表中(§4.7.3)。在运行时,当有异常出现之后,Java 虚拟机就按照 Class 文件中的异常处理器表描述异常处理器的先后顺序,从前至后进行搜索。
    * 需要注意,Java 虚拟机身不会对方法的对异常处理器表做排序或者其他方式的强制处理, 所以 Java 语言中对异常处理的语义,实际上是通过编译器适当安排异常处理器在表中的顺序来协助完成的。在 Class 文件中定义了明确的异常处理器查找顺序,才能保证无论 Class 文件是通过 何种途径产生的,Java 虚拟机执行时都能有一致的行为表现。
  * 2.11 字节码指令集简介
    * Java 虚拟机的指令由一个字节长度的、代表着某种特定操作 义的操作码(Opcode)以及 跟随其后的零至多个代表此操作所需参数的操作数(Operands)所构成。虚拟机中许多指令并不包含操作数,只有一个操作码。





