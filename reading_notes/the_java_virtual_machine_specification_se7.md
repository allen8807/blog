# Java 虚拟机规范(Java SE7版)
#### The Java Virtual Machine Specification SE7

### 第 1 章 引言
* Java 语言是一门通用的、面向对象的、支持并发的程序语言。
* Java 虚拟机是整个 Java 平台的基石,是 Java 技术用以实现硬件无关与操作系统无关的关键部分,是 Java 语言生成出极小体积的编译代码的运行平台,是保障用户机器免于恶意代码损害 的保护屏障。
* Java 虚拟机与 Java 语言并没有必然的联系,它只与特定的二进制文件格式——Class 文件 格式所关联,Class 文件中包含了 Java 虚拟机指令集(或者称为字节码、Bytecodes)和符号 表,还有一些其他辅助信息。
* 基于安全方面的考虑,Java 虚拟机要求在 Class 文件中使用了许多强制性的语法和结构化 约束,但任一门功能性语言都可以表示为一个能被 Java 虚拟机接收的有效的 Class 文件。作为 一个通用的、机器无关的执行平台,任何其他语言的实现者都可以将 Java 虚拟机作为他们语言的 产品交付媒介。

### 第 2 章 Java 虚拟机结构

* 编译后被 Java 虚拟机所执行的代码使用了一种平台中立(不依赖于特定硬件及操作系统的) 的二进制格式来表示,并且经常(但并非绝对)以文件的形式存储,因此这种格式被称为 Class 文件格式。Class 文件格式中精确地定义了类与接口的表示形式,包括在平台相关的目标文件格 式中一些细节上的惯例1,例如字节序(Byte Ordering)等。
* Java 虚拟机可以操作的数据类型可分为两类:原始类 型(Primitive Types,也经常翻译为原生类型或者基本类型)和引用类型(Reference Types)。
* Java 虚拟机是直接支持对象的
* 虚拟机中使用 reference 类型来表示对某个对象的引用,reference 类型的 值读者可以想象成类似于一个指向对象的指针。每一个对象都可能存在多个指向它的引用,对象的 操作、传递和检查都通过引用它的 reference 类型的数据进行操作。
* Java 虚拟机所支持的原始数据类型包括了数值类型(Numeric Types)、布尔类型(Boolean Type §2.3.4)和 returnAddress 类型(§2.3.3)三类。其中数值类型又分为整型类型 (Integral Types,§2.3.1)和浮点类型(Floating-Point Types,§2.3.2)两种
* int 类型:值为 32 位有符号二进制补码整数,默认值为零。
* double 类型:取值范围是双精度浮点数集合中的元素,或者(如果虚拟机支持的话)是 双精度扩展指数(Double-Extended-Exponent)集合中的元素。默认值为正数零。
* boolean 类型:取值范围为布尔值 true 和 false,默认值为 false。
* returnAddress 类型:表示一条字节码指令的操作码(Opcode)。在所有的虚拟机支持的原始类型之中,只有 returnAddress 类型是不能直接 Java 语言的数据类型对应 起来的。
* 对于一个非零的、可数的任意浮点值,都可以表示为 s×m×2<sup>(e-N+1)</sup>的形式,其中 s 可以是 +1 或者-1,m 是一个小于 2N 的正整数,e 是一个介于 Emin=-(2<sup>K-1</sup>-2)和 Emax=2<sup>K-1</sup>-1 之间的整 数(包括 Emin 和 Emax)。这里的 N 和 K 两个参数的取值范围决定于当前采用的浮点数值集合。
* 所有 Java 虚拟机的实现都必须支持两种标准的浮点数值集合:单精度浮点数集合和双精度浮 点数集合。另外,Java 虚拟机实现可以自由选择是否要支持单精度扩展指数集合和双精度扩展指 数集合,也可以选择支持其中的一种或全部。这些扩展指数集合可能在某些特定情况下代替标准浮 点数集合来表示 float 和 double 类型的数值。
* 上述四种数值集合都不仅包含可数的非零值,还包括五个特殊的数值:正数零、负数零、正无 穷大、负无穷大和 NaN。
* returnAddress 类型会被 Java 虚拟机的 jsr、ret 和 jsr_w 指令所使用。
* 这几条指令以前主要被使用来实现 finally 语句块,后来改为冗余 finally 块代码的方式来实 现,甚至到了 JDK7 时,虚拟机已不允许 Class 文件内出现这几条指令。那相应地,returnAddress 类型就处 于名存实亡的状态。
*  Java 虚拟机定义了 boolean 这种数据类型,但是只对它提供了非常有限的支持。在 Java 虚拟机中没有任何供 boolean 值专用的字节码指令,在 Java 语言之中涉及到 boolean 类型值的运算,在编译之后都使用 Java 虚拟机中的 int 数据类型来代替。
*  Java 虚拟机直接支持 boolean 类型的数组,虚拟机的 newarray 指令可以创建这种数组。boolean 的数组类型的访问与修改共用 byte 类型数组的 baload 和 bastore 指令。
*  在 Oracle 公司的虚拟机实现里,Java 语言里面的 boolean 数组将会被编码成 Java 虚拟机的 byte 数 组,每个 boolean 元素占 8 位长度。
*  Java虚拟机中有三种引用类型:类类型(Class Types)、数组类型(Array Types)和 接口类型(Interface Types)。
* 2.5 运行时数据区
* Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区,其中有一些会随着虚拟机 启动而创建,随着虚拟机退出而销毁。
  *  2.5.1 PC 寄存器
    *  Java 虚拟机可以支持多条线程同时执行,每一条 Java 虚拟机线程都有自己的PC(Program Counter)寄存器。
  *  2.5.2 Java 虚拟机栈
    *  这个栈与线程同时创建,用于存储栈帧
    *  栈帧可以在堆中分配,Java 虚拟机栈所使用的内存不需要保证是连 续的。
    *  如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量时,Java 虚拟机将会抛出一个 StackOverflowError 异常。
    *   如果 Java 虚拟机栈可以动态扩展,并且扩展的动作已经尝试过,但是目前无法申请到足够的内存去完成扩展,或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈,那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。
  * 2.5.3 Java 堆
    * 在 Java 虚拟机中,堆(Heap)是可供各条线程共享的运行时内存区域,也是供所有类实例 和数组对象分配内存的区域。
    * Java 堆在虚拟机启动的时候就被创建,它存储了被自动内存管理系统(Automatic Storage Management System,也即是常说的“Garbage Collector(垃圾收集器)”)所管理的各种 对象,这些受管理的对象无需,也无法显式地被销毁。
    * 本规范中所描述的 Java 虚拟机并未假设采 用什么具体的技术去实现自动内存管理系统。虚拟机实现者可以根据系统的实际需要来选择自动内 存管理技术。
    * Java 堆所使用的内存不需要保证是连续的。
    * 如果实际所需的堆超过了自动内存管理系统能提供的最大容量,那Java虚拟机将会抛出一个OutOfMemoryError 异常。
  * 2.5.4 方法区
    * 方法区(Method Area)是可供各条线程共享的运行时内存区域
    * 方法区与传统语言中的编译代码储存区(Storage Area Of Compiled Code)或者操作系统进程 的正文段(Text Segment)的作用非常类似
    * 它存储了每一个类的结构信息,例如运行时常量 池(Runtime Constant Pool)、字段和方法数据、构造函数和普通方法的字节码内容、还包 括一些在类、实例、接口初始化时用到的特殊方法
    * 方法区在虚拟机启动的时候被创建,虽然方法区是堆的逻辑组成部分,但是简单的虚拟机实现 可以选择在这个区域不实现垃圾收集。
    * 方法区在实际内存空间中可以是不连续的。
    * 如果方法区的内存空间不能满足内存分配请求,那Java虚拟机将抛出一个OutOfMemoryError 异常。
  * 2.5.5 运行时常量池
    * 运行时常量池扮演了类似传统语言中符号表(Symbol Table)的角色,不过它存储数据范围比通常意义上的符号表要更为广泛
  * 2.5.6 本地方法栈
    * Java虚拟机实现可能会使用到传统的栈(通常称之为“C Stacks”)来支持native方法 (指使用 Java 以外的其他语言编写的方法)的执行,这个栈就是本地方法栈(Native Method Stack)。
    * 当 Java 虚拟机使用其他语言(例如 C 语言)来实现指令集解释器时,也会使用到本地 方法栈。
    * 如果 Java 虚拟机不支持 natvie 方法,并且自己也不依赖传统栈的话,可以无需支持本 地方法栈,如果支持本地方法栈,那这个栈一般会在线程创建的时候按线程分配。

* 2.6 栈帧
  * 栈帧(Frame)是用来存储数据和部分过程结果的数据结构,同时也被用来处理动态链接 (Dynamic Linking)、方法返回值和异常分派(Dispatch Exception)。
  * 栈帧随着方法调用而创建,随着方法结束而销毁——无论方法是正常完成还是异常完成(抛出 了在方法内未被捕获的异常)都算作方法结束。栈帧的存储空间分配在 Java 虚拟机栈(§2.5.5) 之中,每一个栈帧都有自己的局部变量表(Local Variables,§2.6.1)、操作数栈(Operand Stack,§2.6.2)和指向当前方法所属的类的运行时常量池(§2.5.5)的引用。
  * 在一条线程之中,只有目前正在执行的那个方法的栈帧是活动的。这个栈帧就被称为是当前栈 帧(Current Frame)
  * 当方法返回的之际,当前栈帧会传回此方法的执行结果给前一个栈帧,在方法返回之后,当前栈帧就随之被丢弃,前一个栈帧就重新成为当前栈帧了。 
  * 栈帧是线程本地私有的数据,不可能在一个栈帧之中引用另外一条线程的栈帧。
  * 2.6.1 局部变量表
    * 局部变量使用索引来进行定位访问,第一个局部变量的索引值为零,局部变量的索引值是从零 至小于局部变量表最大容量的所有整数。
    * Java 虚拟机也不要求 double 和 long 类型数据采用 64 位对齐的方式存放在连续的局部变量中
  * 2.6.2 操作数栈
    * 每一个栈帧(§2.6)内部都包含一个称为操作数栈(Operand Stack)的后进先出 (Last-In-First-Out,LIFO)栈。
    * 在操作数栈中的数据必须被正确地操作,这里正确操作是指对操作数栈的操作必须与操作数栈 栈顶的数据类型相匹配
    * 有一小部分Java虚拟机指令(例如 dup 和 swap 指令)可以不关注操作数的具体数据类型,把所有在运行时数据区中的数据当作裸类型(Raw Type)数据来操作,这些指令不可以用来修改数据,也不可以拆散那些原本不可拆分的数据,这些操作的正确性将会通过 Class 文件的校验过程(§4.10)来强制保障。
    * 在任意时刻,操作数栈都会有一个确定的栈深度,一个 long 或者 double 类型的数据会占用 两个单位的栈深度,其他数据类型则会占用一个单位深度。
  * 2.6.3 动态链接
    * 每一个栈帧(§2.6)内部都包含一个指向运行时常量池(§2.5.5)的引用来支持当前方法 的代码实现动态链接(Dynamic Linking)。
    * 动态链接的作用就是 将这些符号引用所表示的方法转换为实际方法的直接引用
    * 由于动态链接的存在,通过晚期绑定(Late Binding)使用的其他类的方法和变量在发生 变化时,将不会对调用它们的方法构成影响。
  * 2.6.4 方法正常调用完成
    * 当前栈帧(§2.6)承担着回复调用者状态的责任
    * 调用者的代 码能在被调用的方法返回并且返回值被推入调用者栈帧的操作数栈后继续正常地执行。
  * 2.6.5 方法异常调用完成
    * 如果方法异常调用完成,那一 定不会有方法返回值返回给它的调用者。
* 2.7 对象的表示
  * Java 虚拟机规范不强制规定对象的内部结构应当如何表示。
* 2.8 浮点算法
  * 2.8.1 Java 虚拟机和 IEEE 754 中的浮点算法
    * 在 Java 虚拟机中的浮点操作在遇到非法操作,如被零除(Divison By Zero)、上限溢出(Overflow)、下限溢出(Underflow)和非精确(Inexact)时,不会抛出exception、trap 或者其他 IEEE 754 异常情况中定义的信号。
    * 在Java虚拟机中不支持IEEE754中的信号浮点比较(SignalingFloating-PointComparisons)。
    * 在 Java 虚拟机中,舍入操作永远使用 IEEE 754 规范中定义的向最接近数舍入模式(Round To Nearest Mode),无法精确表示的结果将会舍入为最接近的可表示值来 保证此值的最低有效位为零(A Zero Least-Significant Bit),这种模式也是 IEEE 754 中的默认模式。
    * 不过在 Java 虚拟机里面,将浮点数转化为整型数是使用向零舍入(Round Toward Zero),这点属于特别定义,并不意味着 Java 虚拟机要改变浮点运算的舍入模式。
    * 在Java虚拟机中不支持IEEE754的单精度扩展和双精度扩展格式(SingleExtended Or Double Extended Format),但是在双精度浮点数集合和双精度扩展指数集合 (Double And Double Extended-Exponent Value Sets,§2.3.2)范围与单 精度扩展指数格式的表示方位会有重叠。
  * 2.8.2 浮点模式
    * 每一个方法都有一项属性称为浮点模式(Floating-Point Mode),取值有两种,要么是 FP-strict 模式要么是非 FP-strict 模式。
  * 2.8.3 数值集合转换
    * 在一些特定场景下,支持扩展指数集合的 Java 虚拟机实现数值在标准浮点数集合与扩展指数 集合之间的映射关系是允许和必要的,这种映射操作就称为数值集合转换。数值集合转换并非数据 类型转换,而是在同一种数据类型之中不同数值集合的映射操作。
    * 



