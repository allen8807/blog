# Java 并发编程实践
## Java Concurrency in Practice

## Chapter 1 简介
* 多程序产生原因：提高资源利用率，公平性，便利性
* 线程是轻量级进程
* 线程优势：多处理器，建模简单，异步事件响应，用户界面反应灵敏
* 线程风险：安全性，活跃性，性能问题

## Chapter 2 线程安全性
* 正确使用线程和锁
* 线程安全代码的核心是对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问 
* 线程安全最核心的是正确性。
* 原子性
    * 竞态条件 因为不恰当的执行条件而出现不正确的结果
    * 复合操作
* 加锁机制
    * 内置锁（Intrinsic Lock）或监视器锁（Monitor Lock） 相当于一种互斥锁。线程进入同步代码会自动获得锁，离开会自动释放锁。
    * 重入 这意味着获取锁的操作粒度是“线程”而不是“调用”。Java中同一线程可以重入自己持有的内置锁，不然可能会死锁，如递归调用的时候。pthread互斥体的粒度是“调用”。
* 用锁保护状态
    * 只有在写入共享变量时才需要使用同步是错误的。
    * 每个共享的和可变的变量都应该只由一个锁来保护。
    * 包含多个变量的不变性条件，涉及的所有变量都需要由同一个锁来保护。
* 活跃性和性能
    * 简单性和性能之间存在制约，但是不能盲目为了性能而牺牲简单性，因为可能会破坏安全性。
    * 执行长时间的计算或者操作的时候，不要持有锁。

## Chapter 3 对象的共享
* 关键字synchronized 一方面可以用于实现原子性或者确定“临界区（Critical Section）”，另一个重要的方面在于内存可见性（Memory Visibility）。
* 安全发布




